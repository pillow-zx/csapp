	1.大多数计算机使用字节（byte）作为最小的可寻址单位，一个字节包含8个位。这意味着计算机所能使用的存储空间的最小单位就是字节，比如说有一个大小为10bit的文件，计算机存储这份文件需要的内存不是相应的10bit,而是需要2byte, 即16it.并且剩余未使用的6bit在清理掉这份文件之前将无法使用（这一点与文件系统有关）

	2.机器级程序将内存视为一个非常大的字节数组，成为虚拟内存（virtual memory），内存的每一个字节都有一个唯一的数字来标识，成为它的地址（adress），所有可能的地址的集合就称为虚拟地址空间（virtual adress space）。

#### 一. 十六进制表示法

	这里仅解释一种快速的将2的n次幂转化为十六进制的方法：
	已知2的n次幂的二进制表示就是1后面跟n个0, 十六进制中一个0代表4个二进制中的0。比如对于x=2^n，当n表示成i+4j的形式（0<=i<=3），就可以把x写成开头的十六进制为1（i=0），2（i=1），4（i=2）或者8（i=3），后面跟随着j个十六进制的0
	比如：x=2048=2^11，因为n=11=3+4*2, 从而得到十六进制表示ox800.

#### 二. 字数据的大小
	每台计算机都有一个字长（word size），指明指针数据的标称大小（nominal size）。字长最重要的系统参数就是虚拟地址空间的最大大小。对于一个字长为w的机器而言，虚拟地址的范围为0~2^w-1，程序最多能访问2^w个字节。
		对于32位程序而言，可以在32位和64位计算机上运行
		对于64位程序而言，仅能在64位计算机上运行
		此处的32位和64位指编译时选择的位数，程序指编译后的二进制程序
	
| 数据类型                          | 32 位系统  | 64 位系统 |
| ----------------------------- | ------- | ------ |
| `char`                        | 1       | 1      |
| `short`                       | 2       | 2      |
| `int`                         | 4       | 4      |
| `long`                        | 4       | 8      |
| `long long`                   | 8       | 8      |
| `float`                       | 4       | 4      |
| `double`                      | 8       | 8      |
| `long double`                 | 12 或 16 | 16     |
| `pointer` (`void*`, `int*` 等) | 4       | 8      |
| unsigned char                 | 1       | 1      |
| unsigned short                | 2       | 2      |
| unsigned                      | 4       | 4      |
| unsigned long                 | 4       | 8      |
| unit32_t                      | 4       | 4      |
| unit64_t                      | 8       | 8      |
| int32_t                       | 4       | 4      |
| int64_t                       | 8       | 8      |
	**int32_t**和**int64_t**是ISO C99标准引入的新数据类型，此举意在解决不同位系统见代码移植性差的问题。

#### 三. 寻址和字节顺序

对于跨越多字节的程序对象必须有两个规则： 这个对象的地址是什么，以及在内存中如何排列这些字节。在几乎所有的机器上，多字节对象都被存储为连续的字符序列，对象的地址为所使用字节中最小的地址

排列表示一个对象的字节有两种通用规则

	1.对于在内存中按照从最低有效字节到最高有效字节的顺序存储对象的称做**小端法**（little endian）。

	2.对于在内存中按照从最高有效字节到最低有效字节的顺序存储对象的称做**大端法**（big endian）。

![[Pasted image 20250321201251.png]]


	为防止因不同机器存储对象的方法不同在网络中传输数据造成不便，网络应用程序的代码必须遵守已建立的关于字节顺序的轨辙

#### 四. 移位运算

c语言除了逻辑运算和位级运算之外还提供了一组移位运算，包含向左和向右两种模式，分别可以表示为


```
a << x; （向左移动x位）
a >> x; （向右移动x位）
```

**1.左移运算符** `<<`: 

**作用**：把一个数的 **二进制位** 向左移动 **指定的位数**，右侧空出的位用 **0** 填充。  
**2.右移运算符** `>>` :

**作用**：把一个数的 **二进制位** 向右移动 **指定的位数**。

- **逻辑右移（无符号数）：高位补 0**
- **算术右移（有符号数）：高位补符号位（即原来的最高位）**

c语言标准并没有明确对于有符号数应该使用那种类型的右移，算术右移或者逻辑右移都可以，不过，实际上几乎所有的编译器/机器组合都会对有符号数使用算术右移，对于无符号数，右移必须是逻辑的。

**补充**：
	1.假如对于一个32为的变量a，进行a >> k ，（k大于32）操作会怎么样呢？实际上C标准已经考虑到了这种情况，当移动一个k为的值时，移位指令位移量的低**loa2(k)** 位， 因此实际上是位移量就是通过计算 a mod k 得到的。
	2.位移运算符的优先度较低，与其他运算符结合使用时应尽量使用括号。如：1 << 2 + 3 << 4 的运算为先+ 后进行移位，实际写时应写为：(1 << 2) + (3 << 4)





